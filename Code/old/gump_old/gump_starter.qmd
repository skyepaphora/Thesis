# Setup

```{r packages}
# Code ------------
library(multitaper) # spec.mtm, etc.
library(pbapply)    # Progress bar for apply() functions
library(itsmr)      # Time series stuff, used here for ARMA
library(nleqslv)    # Stupidly named nonlinear solving package
library(nloptr)     # A more flexible nonlinear solver

# Presentation ----
library(kableExtra) # Nice Tables
library(animation)  # For creating gifs
library(fields)     # Supplement image plots: legends, better colour schema

# Skye Plots ------
load("~/Research/Skyes_Toolbox/plots_and_palettes/spalette.RData")
load("~/Research/Skyes_Toolbox/plots_and_palettes/splot.RData")

# Other -----------
options(digits = 10)
```

```{r load_data}
# Data ----
load("~/Research/PhD_Thesis/Data/GUMP_pbc/3-Eyed___B200_sd1___mini.RData")
# load("~/Research/PhD_Thesis/Data/GUMP_pbc/butterfly___B200_sd1___mini.RData")


# Simple naming for TRUE unknowns (TFS and vectors) ----
SX <- info$tru$SX
g1 <- info$tru$gt.1
g2 <- info$tru$gt.2
S1 <- info$tru$SY.1
S2 <- info$tru$SY.2
```

## Partitioning & (de)Construction

```{r partitioning}
# Naming
abcd <- LETTERS[1:4]
varnames <- sapply(c("g1.","g2.","S1.","S2."), function(z){paste0(z,abcd)})

# Cell definitions ----
NN <- list(A = (0*N/4 +1):(1*N/4), 
           B = (1*N/4 +1):(2*N/4),
           C = (2*N/4 +1):(3*N/4),
           D = (3*N/4 +1):(4*N/4))

MM <- list(A = floor(0*NF/4 +1):floor(1*NF/4),
           B = floor(1*NF/4 +1):floor(2*NF/4), 
           C = floor(2*NF/4 +1):floor(3*NF/4), 
           D = floor(3*NF/4 +1):ceiling(4*NF/4))
```

```{r get16_reconstruct}
# Letterboxes and Pillarboxes, given component vecs
get.16 <- function(G1,G2,s1,s2){
  blocks <- c()
  for(j in 1:4){
    blocks[j]    <- sum(G1[NN[[j]] ])
    blocks[j+4]  <- sum(G2[NN[[j]] ])
    blocks[j+8]  <- sum(s1[MM[[j]] ])
    blocks[j+12] <- sum(s2[MM[[j]] ])
  }
  names(blocks)  <- varnames
  return(blocks)
}

# Create SX, given component vecs
reconstruct <- function(G1,G2,s1,s2){
  return(outer(s1,G1) + outer(s2,G2))
}
```

```{r true16}
# 16 true Unknowns
unknowns.true <- get.16(g1,g2,S1,S2)
```

## Math: Solving for g, assuming spectra are known

$$
\begin{aligned}
    S_X(t,f_i) &= g_1(t)S_1(f_i) + g_2(t)S_2(f_i)  \\
    S_X(t,f_j) &= g_1(t)S_1(f_j) + g_2(t)S_2(f_j)  \\
    &\\ 
    g_1(t) &= \frac{S_X(t,f_j)S_1(f_j) - S_X(t,f_i)S_2(f_j)}
                   {S_1(t,f_j)S_2(f_i) - S_1(t,f_i)S_2(f_j)} 
                   \\ & \\
    g_2(t) &= \frac{S_X(t,f_i)S_2(f_i) - S_X(t,f_j)S_1(f_i)}
                   {S_1(t,f_j)S_2(f_i) - S_1(t,f_i)S_2(f_j)}
\end{aligned}
$$

# SVD Method

```{r svd}
SX.svd <- svd((SX)) #, nu = 2, nv = 2)
```

```{r svd_sanity}
# # Sanity Check ----
# test  <- SX.svd$u %*% diag(SX.svd$d) %*% t(SX.svd$v)
# test1 <- outer(SX.svd$u[,1]*sqrt(SX.svd$d[1]),(SX.svd$v[,1]*sqrt(SX.svd$d[1])))
# test2 <- outer(SX.svd$u[,2]*sqrt(SX.svd$d[2]),(SX.svd$v[,2]*sqrt(SX.svd$d[2])))
# 
# max(abs(SX - test))
# max(abs(info$tru$SX.1 - test1))
# max(abs(info$tru$SX.2 - test2))
# 
# par(mfrow = c(3,2))
# image.plot(info$tru$SX.1); image.plot(test1)
# image.plot(info$tru$SX.2); image.plot(test2)
# image.plot(info$tru$SX  ); image.plot(test )
```

#### NOTES
Idea: these singular vectors are orthogonal, contrary to the original component vectors
(they've projected onto an orthogonal space)
So, can we get the component vectors from this?
(Skye-visual: multiply by a diagonal matrix = diagonal element times each col)

```{r svd}
# SVD translation
trans <- function(z, buff = 0.1){ z - min(z) + buff }
# trans <- function(z){z}

g1.svd <- trans(SX.svd$u[,1]*sqrt(SX.svd$d[1]))
g2.svd <- trans(SX.svd$u[,2]*sqrt(SX.svd$d[2]))

S1.svd <- trans(SX.svd$v[,1]*sqrt(SX.svd$d[1]))
S2.svd <- trans(SX.svd$v[,2]*sqrt(SX.svd$d[2]))
```

```{r svd_plot}
par(mfrow = c(4,2))

lim.g <- range(g1,g2,g1.svd,g2.svd)
lim.S <- range(S1,S2,S1.svd,S2.svd)
zero  <- function(){abline(h=0,lty=2)}

plot(g1, ylim = lim.g); zero();    plot(g1.svd, ylim = lim.g); zero()
plot(g2, ylim = lim.g); zero();    plot(g2.svd, ylim = lim.g); zero()
plot(S1, ylim = lim.S); zero();    plot(S1.svd, ylim = lim.S); zero()
plot(S2, ylim = lim.S); zero();    plot(S2.svd, ylim = lim.S); zero()
```

# StoGO

```{r cobylaSetup}
# Parameters ----
U  <- lapply(MM, function(x){rowSums(SX[,x])})
V  <- lapply(NN, function(x){colSums(SX[x,])})

# UHAT: Compute cellwise Power
U.hat <- matrix(NA, 4, 4, dimnames = list(abcd,abcd))
for(theta in 1:4){
  for(phi in 1:4){
    U.hat[theta,phi] <- sum(SX[NN[[theta]], MM[[phi]] ])
  }
}
Uhat <- sum(U.hat)


# Objective functions ----
fn.0 <- function(x){(sum(outer(x[1:4],x[9:12]) + outer(x[5:8],x[13:16]) ) - Uhat)^2} 

fn.1 <- function(x){
  
  g1.hat <- (U$A*x[14]-U$B*x[13]) / (x[ 9]*x[14]-x[10]*x[13])  
  g2.hat <- (U$A*x[10]-U$B*x[ 9]) / (x[13]*x[10]-x[14]*x[ 9])  
  S1.hat <- (V$A*x[ 6]-V$B*x[ 5]) / (x[ 1]*x[ 6]-x[ 2]*x[ 5])  
  S2.hat <- (V$A*x[ 2]-V$B*x[ 1]) / (x[ 5]*x[ 2]-x[ 6]*x[ 1]) 
  
  max(abs(reconstruct(g1.hat,g2.hat,S1.hat,S2.hat) - t(SX)))
  }

# Objective function
eval_f <- function(x) {
  list(
    "objective" 
          #           g1     S1               g2     S2
          = (sum(outer(x[1:4],x[9:12]) + outer(x[5:8],x[13:16]) ) - Uhat)^2,
    "gradient" 
          = c(sum(x[ 9:12]),sum(x[ 9:12]),sum(x[ 9:12]),sum(x[ 9:12]), # g1
              sum(x[13:16]),sum(x[13:16]),sum(x[13:16]),sum(x[13:16]), # g2
              sum(x[ 1: 4]),sum(x[ 1: 4]),sum(x[ 1: 4]),sum(x[ 1: 4]), # S1
              sum(x[ 5: 8]),sum(x[ 5: 8]),sum(x[ 5: 8]),sum(x[ 5: 8])) # S2
    )
}

# SVD translation
sd.trans <- function(z){
  z - min(z) + 0.1
}
```

```{r top}
top <- c( 
  unlist(rep( lapply(NN, FUN = function(z){max(colSums(SX[z, ]))}),  2)),
  unlist(rep( lapply(MM, FUN = function(z){max(rowSums(SX[ ,z]))}),  2)))
names(top) <- varnames
```

```{r}
test.0 <- unknowns.true + rnorm(16, 0, 10)
test.0 <- unknowns.true + rnorm(16, 0, 100)
test.0 <- sd.trans(get.16(g1.svd,g2.svd,S1.svd,S2.svd))


test.0 <- unknowns.true*2
```

```{r}
# local_opts <- list("algorithm" = "NLOPT_LD_MMA", "xtol_rel"  = 1.0e-7)
opts <- list("algorithm"   = "NLOPT_GD_STOGO",
             "xtol_rel"    = 1.0e-7,
             "maxeval"     = 2000,
             # "local_opts"  = local_opts,
             "print_level" = 0)

result <- nloptr(x0 = test.0,
             eval_f = eval_f,
             # lb = rep(0,16),
             # ub = top,
             opts = opts
)
```

```{r}
# nonlinear solver results
x <- result$solution
names(x) <- varnames
  
# Solve for time functions
g1.hat <- (U$A*x["S2.B"]-U$B*x["S2.A"]) / (x["S1.A"]*x["S2.B"]-x["S1.B"]*x["S2.A"])
g2.hat <- (U$A*x["S1.B"]-U$B*x["S1.A"]) / (x["S2.A"]*x["S1.B"]-x["S2.B"]*x["S1.A"])
  
# Solve for freq functions
S1.hat <- (V$A*x["g2.B"]-V$B*x["g2.A"]) / (x["g1.A"]*x["g2.B"]-x["g1.B"]*x["g2.A"])
S2.hat <- (V$A*x["g1.B"]-V$B*x["g1.A"]) / (x["g2.A"]*x["g1.B"]-x["g2.B"]*x["g1.A"])
```

```{r}
# Normalization function 
no <- function(z){z/max(abs(z))}
no <- function(x){x}  # (easy on/off in case you want full scale)

# prep plots ----
par(mfrow = c(2,2), mar = c(4,4,2,1))
lim <- list(range(no(g1),no(g1.hat),no(g1.svd)), range(no(g2),no(g2.hat),no(g2.svd)),
            range(no(S1),no(S1.hat),no(S1.svd)), range(no(S2),no(S2.hat),no(S2.svd)))
# lim <- lapply(lim, function(x){c(-0.5,1)})

# Plotting ----
plot(t, no(g1),
     main = "Normalized g1 estimate", ylim = lim[[1]], type = "l")
     abline(h=0, lty = 2, col = "grey50")
     lines(t, no(g2), col = "grey77")
     lines(t, no(g1.svd), col = "dodgerblue")
     lines(t, no(g1.hat), col = "red", lwd = 2)
plot(t, no(g2),
     main = "Normalized g2 estimate", ylim = lim[[2]], type = "l")
     abline(h=0, lty = 2, col = "grey50")
     lines(t, no(g1), col = "grey77")
     lines(t, no(g2.svd), col = "dodgerblue")
     lines(t, no(g2.hat), col = "red", lwd = 2)
plot(f, no(S1),
     main = "Normalized S1 estimate", ylim = lim[[3]], type = "l")
     abline(h=0, lty = 2, col = "grey50")
     lines(f, no(S2), col = "grey77")
     lines(f, no(S1.svd), col = "dodgerblue")
     lines(f, no(S1.hat), col = "red", lwd = 2)
plot(f, no(S2),
     main = "Normalized S2 estimate", ylim = lim[[4]], type = "l")
     abline(h=0, lty = 2, col = "grey50")
     lines(f, no(S1), col = "grey77")
     lines(f, no(S2.svd), col = "dodgerblue")
     lines(f, no(S2.hat), col = "red", lwd = 2)
```

nlopt_opt_set_local_optimizer

# MLSL
```{r}
local_opts <- list("algorithm" = "NLOPT_GN_DIRECT", "xtol_rel"  = 1.0e-7)
opts <- list("algorithm"   = "NLOPT_GN_MLSL",
             "xtol_rel"    = 1.0e-7,
             "maxeval"     = 2000,
             "local_opts"  = local_opts,
             "print_level" = 0)

results <- nloptr(x0 = test.0,
             eval_f = fn.2,
             # lb = rep(0,16),
             # ub = top,
             opts = opts
)
```





# COBYLA: Constrained Optimization BY Linear Approximations

```{r cobylaSetup}
# Parameters - hard coding these right now, but I think nloptr can take Uhat
U  <- lapply(MM, function(x){rowSums(SX[,x])})
V  <- lapply(NN, function(x){colSums(SX[x,])})

# UHAT: Compute cellwise Power
U.hat <- matrix(NA, 4, 4, dimnames = list(abcd,abcd))
for(theta in 1:4){
  for(phi in 1:4){
    U.hat[theta,phi] <- sum(SX[NN[[theta]], MM[[phi]] ])
  }
}
Uhat <- sum(U.hat)


# Objective function
fn.0 <- function(x){(sum(outer(x[1:4],x[9:12]) + outer(x[5:8],x[13:16]) ) - Uhat)^2} # maybe do the sum of?

fn.1 <- function(x){
  
  g1.hat <- (U$A*x[14]-U$B*x[13]) / (x[ 9]*x[14]-x[10]*x[13])  
  g2.hat <- (U$A*x[10]-U$B*x[ 9]) / (x[13]*x[10]-x[14]*x[ 9])  
  S1.hat <- (V$A*x[ 6]-V$B*x[ 5]) / (x[ 1]*x[ 6]-x[ 2]*x[ 5])  
  S2.hat <- (V$A*x[ 2]-V$B*x[ 1]) / (x[ 5]*x[ 2]-x[ 6]*x[ 1]) 
  
  max(abs(reconstruct(g1.hat,g2.hat,S1.hat,S2.hat) - t(SX)))
  }






# Inequality constraints ----
hin.0 <- function(x){ c(
  max( -((U$A*x[14]-U$B*x[13]) / (x[ 9]*x[14]-x[10]*x[13])) ), 
  max( -((U$A*x[10]-U$B*x[ 9]) / (x[13]*x[10]-x[14]*x[ 9])) ), 
  max( -((V$A*x[ 6]-V$B*x[ 5]) / (x[ 1]*x[ 6]-x[ 2]*x[ 5])) ), 
  max( -((V$A*x[ 2]-V$B*x[ 1]) / (x[ 5]*x[ 2]-x[ 6]*x[ 1])) ))
}

hin.alt  <- function(x){ c(
  max( -((U$C*x[16]-U$D*x[15]) / (x[11]*x[16]-x[12]*x[15])) ), 
  max( -((U$C*x[12]-U$D*x[11]) / (x[15]*x[12]-x[16]*x[11])) ), 
  max( -((V$C*x[ 8]-V$D*x[ 7]) / (x[ 3]*x[ 8]-x[ 4]*x[ 7])) ), 
  max( -((V$C*x[ 4]-V$D*x[ 3]) / (x[ 7]*x[ 4]-x[ 8]*x[ 3])) ))
} # Alternative cell choices (A -> C and B -> D)
```


```{r initialize}
test.0   <- unknowns.true*2
test.1   <- test.0/test.0
test.svd <- get.16(g1.svd,g2.svd,S1.svd,S2.svd)


test.ump <- c(test.0[1]+test.0[5], 
              test.0[2]+test.0[6],
              test.0[3]+test.0[7],
              test.0[4]+test.0[8],0,0,0,0,
              test.0[1]+test.0[5], 
              test.0[2]+test.0[6],
              test.0[3]+test.0[7],
              test.0[4]+test.0[8],0,0,0,0)

test.ump <- c(sum(colSums(SX[NN[[1]],])),
              sum(colSums(SX[NN[[2]],])), 
              sum(colSums(SX[NN[[3]],])), 
              sum(colSums(SX[NN[[4]],])), 1,1,1,1,
              sum(rowSums(SX[,MM[[1]]])),
              sum(rowSums(SX[,MM[[2]]])), 
              sum(rowSums(SX[,MM[[3]]])), 
              sum(rowSums(SX[,MM[[4]]])), 1,1,1,1)
test.ump[5:8] <- test.ump[1:4]
test.ump[13:16] <- test.ump[9:12]

test.ump <- test.ump /2 + rnorm(16,100,10)

```

```{r top}
top <- c( 
  unlist(rep( lapply(NN, FUN = function(z){max(colSums(SX[z, ]))}),  2)),
  unlist(rep( lapply(MM, FUN = function(z){max(rowSums(SX[ ,z]))}),  2)))
names(top) <- varnames
```



```{r cobyla}
tol <- 1e-6

cob00 <- cobyla(
         x0  = test.0,                    # Start vector
         fn  = fn.1,                      # Objective function
         hin = hin.0,                     # Inequality constraints
         lower = rep(0,16),               # vector of bounds on output
         # lower = rep(min(test.svd),16),
         upper = top,
         nl.info = TRUE,                  # save optimization info
         deprecatedBehavior = FALSE,      # flip Jac. function (required)
         control = list(xtol_rel = tol,   # stop when step gets this small
                        maxeval = 5000)
         )

# cob0 <- cobyla(
#          x0  = test.svd,                  # Start vector
#          fn  = fn.0,                      # Objective function
#          hin = hin.0,                     # Inequality constraints
#          # lower = rep(0,16),               # vector of bounds on output
#          # lower = rep(min(test.svd),16),
#          # upper = top,
#          nl.info = TRUE,                  # save optimization info
#          deprecatedBehavior = FALSE,      # flip Jac. function (required)
#          control = list(xtol_rel = tol,   # stop when step gets this small
#                         maxeval = 2000)
#          )
```

```{r solve_unknowns}
# nonlinear solver results
x <- cob00$par
names(x) <- varnames
  
# Solve for time functions
g1.hat <- (U$A*x["S2.B"]-U$B*x["S2.A"]) / (x["S1.A"]*x["S2.B"]-x["S1.B"]*x["S2.A"])
g2.hat <- (U$A*x["S1.B"]-U$B*x["S1.A"]) / (x["S2.A"]*x["S1.B"]-x["S2.B"]*x["S1.A"])
  
# Solve for freq functions
S1.hat <- (V$A*x["g2.B"]-V$B*x["g2.A"]) / (x["g1.A"]*x["g2.B"]-x["g1.B"]*x["g2.A"])
S2.hat <- (V$A*x["g1.B"]-V$B*x["g1.A"]) / (x["g2.A"]*x["g1.B"]-x["g2.B"]*x["g1.A"])
```

```{r ALTALTALT}
# nonlinear solver results
x <- cob$par
names(x) <- varnames

# Solve for time functions
g1.hat <- (U$C*x["S2.D"]-U$D*x["S2.C"]) / (x["S1.C"]*x["S2.D"]-x["S1.D"]*x["S2.C"])
g2.hat <- (U$C*x["S1.D"]-U$D*x["S1.C"]) / (x["S2.C"]*x["S1.D"]-x["S2.D"]*x["S1.C"])
  
# Solve for freq functions
S1.hat <- (V$C*x["g2.D"]-V$D*x["g2.C"]) / (x["g1.C"]*x["g2.D"]-x["g1.D"]*x["g2.C"])
S2.hat <- (V$C*x["g1.D"]-V$D*x["g1.C"]) / (x["g2.C"]*x["g1.D"]-x["g2.D"]*x["g1.C"])
```

ratio of the truth to the SVD

```{r}
# Normalization function 
no <- function(z){z/max(abs(z))}
no <- function(x){x}  # (easy on/off in case you want full scale)

# prep plots ----
par(mfrow = c(2,2), mar = c(4,4,2,1))
# lim <- list(range(no(g1),no(g1.hat),no(g1.svd)), range(no(g2),no(g2.hat),no(g2.svd)),
#             range(no(S1),no(S1.hat),no(S1.svd)), range(no(S2),no(S2.hat),no(S2.svd)))

lim <- list(range(no(g1),no(g1.hat)), range(no(g2),no(g2.hat)),
            range(no(S1),no(S1.hat)), range(no(S2),no(S2.hat)))
# lim <- lapply(lim, function(x){c(-0.5,1)})

# Plotting ----
plot(t, no(g1),
     main = "Normalized g1 estimate", ylim = lim[[1]], type = "l")
     abline(h=0, lty = 2, col = "grey50")
     lines(t, no(g2), col = "grey77")
     # lines(t, no(g1.svd), col = "dodgerblue")
     lines(t, no(g1.hat), col = "red", lwd = 2)
plot(t, no(g2),
     main = "Normalized g2 estimate", ylim = lim[[2]], type = "l")
     abline(h=0, lty = 2, col = "grey50")
     lines(t, no(g1), col = "grey77")
     # lines(t, no(g2.svd), col = "dodgerblue")
     lines(t, no(g2.hat), col = "red", lwd = 2)
plot(f, no(S1),
     main = "Normalized S1 estimate", ylim = lim[[3]], type = "l")
     abline(h=0, lty = 2, col = "grey50")
     lines(f, no(S2), col = "grey77")
     # lines(f, no(S1.svd), col = "dodgerblue")
     lines(f, no(S1.hat), col = "red", lwd = 2)
plot(f, no(S2),
     main = "Normalized S2 estimate", ylim = lim[[4]], type = "l")
     abline(h=0, lty = 2, col = "grey50")
     lines(f, no(S1), col = "grey77")
     # lines(f, no(S2.svd), col = "dodgerblue")
     lines(f, no(S2.hat), col = "red", lwd = 2)
```

```{r}
SX.hat <- reconstruct(no(g1.hat),no(g2.hat),no(S1.hat),no(S2.hat))
SX.no  <- reconstruct(no(g1),no(g2),no(S1),no(S2))
max((SX.hat - SX.nof)^2)
```

```{r}
par(mfrow = c(2,2), mar = c(4,4,2,1))
image.plot(f,t, SX.hat, zlim = range(SX.hat, SX.no)); mtext("estimate")
image.plot(f,t, SX.no , zlim = range(SX.hat, SX.no)); mtext("TRUE")
```

```{r}
image.plot(f,t, (SX.hat - SX.no)^2)
```






























